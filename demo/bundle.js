/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// object with all WebAssembly.instance exports
/******/ 	__webpack_require__.w = {};
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./demo/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./demo/app.js":
/*!*********************!*\
  !*** ./demo/app.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _releases_wasm_pitch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../releases/wasm-pitch */ \"./releases/wasm-pitch.js\");\n\r\n\r\nconst buttonEl = document.querySelector('#start');\r\nconst pitchEl = document.querySelector('#pitch');\r\nconst setPitch = pitch => (pitchEl.innerText = pitch >= 0 ? pitch : '__');\r\n\r\n// Is it possible for the function to be static?\r\n// Let's go with non-static => Have to instantiate a wasm-pitch instance to use its functionality\r\n// wasmPitch has to be a class\r\nconst wasmPitch = new _releases_wasm_pitch__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\nwasmPitch.addListener(setPitch);\r\nwasmPitch.loaded().then(() => {\r\n  buttonEl.disabled = false;\r\n  wasmPitch.addListener(setPitch);\r\n  // Initialize the button element\r\n\r\n  buttonEl.onclick = () => {\r\n    if (buttonEl.dataset.state === 'off') {\r\n      buttonEl.innerText = 'Stop';\r\n      buttonEl.dataset.state = 'on';\r\n      wasmPitch.start();\r\n    } else {\r\n      buttonEl.innerText = 'Start';\r\n      buttonEl.dataset.state = 'off';\r\n      wasmPitch.stop();\r\n    }\r\n  };\r\n});\r\n\n\n//# sourceURL=webpack:///./demo/app.js?");

/***/ }),

/***/ "./releases/wasm-pitch.js":
/*!********************************!*\
  !*** ./releases/wasm-pitch.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WasmPitch; });\n/* harmony import */ var _wasm_interface_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wasm_interface.js */ \"./releases/wasm_interface.js\");\n/* harmony import */ var _wasm_interface_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_wasm_interface_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _wasm_interface_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wasm_interface.wasm */ \"./releases/wasm_interface.wasm\");\n\r\n\r\n\r\nclass WasmPitch {\r\n  constructor() {\r\n    this.callbacks = [];\r\n    // TODO(ML): Research if there is a better way to tell if an instance of the class has fully loaded.\r\n    // Currently, I'm using a loadingPromise object to tell if the class has loaded the module object.\r\n    this.mediaStream;\r\n    this.processorNode;\r\n    this.loadingPromise = new Promise((resolve, reject) => {\r\n      this.moduleObj = {\r\n        onRuntimeInitialized: () => {\r\n          resolve();\r\n        },\r\n\r\n        locateFile: (path) => {\r\n          console.log('path:', path);\r\n          // Webpack changes the name and possibly also the path of the '.wasm' file\r\n          // So we have to add this locateFile hook to redirect browser request to the appropriate URL\r\n          if(path.endsWith('.wasm')) {\r\n            console.log('fwasm_interface ', fibonacciModule);\r\n            return fibonacciModule;\r\n          }\r\n          return path;\r\n        },\r\n\r\n        onAbort: () => {\r\n          reject('Loading of wasm-pitch aborted');\r\n        }\r\n      };\r\n    });\r\n\r\n    // Initialises the module object on top of the existing this.moduleObj\r\n    _wasm_interface_js__WEBPACK_IMPORTED_MODULE_0__(this.moduleObj);\r\n  }\r\n\r\n  /**\r\n   * Starts the pitch dictation machinery\r\n   */\r\n  async start() {\r\n\r\n    // Check that the wasm Module object is fully loaded\r\n    try {\r\n      await this.loaded();\r\n    } catch (e) {\r\n      throw e;\r\n    }\r\n\r\n    // Get the media stream from client's microphone using the WebRTC API\r\n    try {\r\n      this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n    } catch (e) {\r\n      throw e;\r\n    }\r\n\r\n    // Set up the audio processing using WebAudio API\r\n    const ctx = new AudioContext();\r\n    const sourceNode = ctx.createMediaStreamSource(this.mediaStream);\r\n    const bufferLength = 1024;\r\n    this.processorNode = ctx.createScriptProcessor(bufferLength, 1, 1);\r\n    this.processorNode.onaudioprocess = evt => {\r\n      const pCMArray = evt.inputBuffer.getChannelData(0);\r\n      let buffer;\r\n      try {\r\n        buffer = this.moduleObj._malloc(pCMArray.byteLength);\r\n        this.moduleObj.HEAPF32.set(pCMArray, buffer >> 2);\r\n        const pitch = this.moduleObj._get_pitch_mpm_c(\r\n          buffer,\r\n          pCMArray.length,\r\n          evt.inputBuffer.sampleRate\r\n        );\r\n        this.callbacks.forEach(callback => callback(pitch));\r\n      } catch (e) {\r\n        throw e;\r\n      } finally {\r\n        this.moduleObj._free(buffer);\r\n      }\r\n    };\r\n    sourceNode.connect(this.processorNode);\r\n    // The audio signal chain has to be completed by connecting to a destination\r\n    this.processorNode.connect(ctx.destination);\r\n  }\r\n\r\n  /**\r\n   *  Resolves when the wasm module has been loaded, rejects if module loader throws error  \r\n   */\r\n  async loaded() {\r\n    try {\r\n      await this.loadingPromise;\r\n      return;\r\n    } catch (e) {\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stops the pitch detection machinery\r\n   */\r\n  stop() {\r\n    if (!this.mediaStream || !this.processorNode) throw Error('start() has not been called');\r\n    \r\n    this.mediaStream.getTracks()[0].stop();\r\n    this.processorNode.disconnect();\r\n  }\r\n\r\n  addListener(callback) {\r\n    this.callbacks.push(callback);\r\n  }\r\n\r\n  removePitchListener(callback) {\r\n    const index = this.callbacks.indexOf(callback);\r\n    if (index === -1) return;\r\n    callbacks.splice(index, 1);\r\n  }\r\n}\n\n//# sourceURL=webpack:///./releases/wasm-pitch.js?");

/***/ }),

/***/ "./releases/wasm_interface.js":
/*!************************************!*\
  !*** ./releases/wasm_interface.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Module = function(Module) {\r\n  Module = Module || {};\r\n\r\nvar a;a||(a=typeof Module !== 'undefined' ? Module : {});var d={},h;for(h in a)a.hasOwnProperty(h)&&(d[h]=a[h]);a.arguments=[];a.thisProgram=\"./this.program\";a.quit=function(b,c){throw c;};a.preRun=[];a.postRun=[];var k=!1,l=!1,p=!1,aa=!1;k=\"object\"===typeof window;l=\"function\"===typeof importScripts;p=\"object\"===typeof process&&\"function\"===\"function\"&&!k&&!l;aa=!k&&!p&&!l;\r\nif(a.ENVIRONMENT)throw Error(\"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)\");\r\nif(p){var q,u;a.read=function(b,c){q||(q=__webpack_require__(/*! fs */ \"fs\"));u||(u=__webpack_require__(/*! path */ \"path\"));b=u.normalize(b);b=q.readFileSync(b);return c?b:b.toString()};a.readBinary=function(b){b=a.read(b,!0);b.buffer||(b=new Uint8Array(b));assert(b.buffer);return b};1<process.argv.length&&(a.thisProgram=process.argv[1].replace(/\\\\/g,\"/\"));a.arguments=process.argv.slice(2);process.on(\"uncaughtException\",function(b){throw b;});process.on(\"unhandledRejection\",function(){v(\"node.js exiting due to unhandled promise rejection\");\r\nprocess.exit(1)});a.quit=function(b){process.exit(b)};a.inspect=function(){return\"[Emscripten Module object]\"}}else if(aa)\"undefined\"!=typeof read&&(a.read=function(b){return read(b)}),a.readBinary=function(b){if(\"function\"===typeof readbuffer)return new Uint8Array(readbuffer(b));b=read(b,\"binary\");assert(\"object\"===typeof b);return b},\"undefined\"!=typeof scriptArgs?a.arguments=scriptArgs:\"undefined\"!=typeof arguments&&(a.arguments=arguments),\"function\"===typeof quit&&(a.quit=function(b){quit(b)});\r\nelse if(k||l)a.read=function(b){var c=new XMLHttpRequest;c.open(\"GET\",b,!1);c.send(null);return c.responseText},l&&(a.readBinary=function(b){var c=new XMLHttpRequest;c.open(\"GET\",b,!1);c.responseType=\"arraybuffer\";c.send(null);return new Uint8Array(c.response)}),a.readAsync=function(b,c,e){var g=new XMLHttpRequest;g.open(\"GET\",b,!0);g.responseType=\"arraybuffer\";g.onload=function(){200==g.status||0==g.status&&g.response?c(g.response):e()};g.onerror=e;g.send(null)},a.setWindowTitle=function(b){document.title=\r\nb};else throw Error(\"environment detection error\");var w=a.print||(\"undefined\"!==typeof console?console.log.bind(console):\"undefined\"!==typeof print?print:null),v=a.printErr||(\"undefined\"!==typeof printErr?printErr:\"undefined\"!==typeof console&&console.warn.bind(console)||w);for(h in d)d.hasOwnProperty(h)&&(a[h]=d[h]);d=void 0;ba=function(){x(\"cannot use the stack before compiled code is ready to run, and has provided stack access\")};function ca(b){var c;c||(c=16);return Math.ceil(b/c)*c}\r\nvar y,da={\"f64-rem\":function(b,c){return b%c},\"debugger\":function(){debugger}},z=0;function assert(b,c){b||x(\"Assertion failed: \"+c)}var ea=\"undefined\"!==typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;\"undefined\"!==typeof TextDecoder&&new TextDecoder(\"utf-16le\");\r\nfunction fa(b){return b.replace(/__Z[\\w\\d_]+/g,function(b){y||(y={});y[\"warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling\"]||(y[\"warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling\"]=1,v(\"warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling\"));return b===b?b:b+\" [\"+b+\"]\"})}\r\nfunction ha(){a:{var b=Error();if(!b.stack){try{throw Error(0);}catch(c){b=c}if(!b.stack){b=\"(no stack trace available)\";break a}}b=b.stack.toString()}a.extraStackTrace&&(b+=\"\\n\"+a.extraStackTrace());return fa(b)}var buffer,A,ia,B,C;\r\nfunction ja(){a.HEAP8=new Int8Array(buffer);a.HEAP16=ia=new Int16Array(buffer);a.HEAP32=B=new Int32Array(buffer);a.HEAPU8=A=new Uint8Array(buffer);a.HEAPU16=new Uint16Array(buffer);a.HEAPU32=C=new Uint32Array(buffer);a.HEAPF32=new Float32Array(buffer);a.HEAPF64=new Float64Array(buffer)}var E,F,G,H,ka,I,J,K;E=F=H=ka=I=J=K=0;G=!1;\r\nfunction L(){34821223==C[(I>>2)-1]&&2310721022==C[(I>>2)-2]||x(\"Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x\"+C[(I>>2)-2].toString(16)+\" \"+C[(I>>2)-1].toString(16));if(1668509029!==B[0])throw\"Runtime error: The application has corrupted its heap memory area (address zero)!\";}\r\nfunction la(){x(\"Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value \"+M+\", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 \")}var ma=a.TOTAL_STACK||5242880,M=a.TOTAL_MEMORY||16777216;M<ma&&v(\"TOTAL_MEMORY should be larger than TOTAL_STACK, was \"+M+\"! (TOTAL_STACK=\"+ma+\")\");\r\nassert(\"undefined\"!==typeof Int32Array&&\"undefined\"!==typeof Float64Array&&void 0!==Int32Array.prototype.subarray&&void 0!==Int32Array.prototype.set,\"JS engine does not provide full typed array support\");\r\na.buffer?(buffer=a.buffer,assert(buffer.byteLength===M,\"provided buffer should be \"+M+\" bytes, but it is \"+buffer.byteLength)):(\"object\"===typeof WebAssembly&&\"function\"===typeof WebAssembly.Memory?(assert(0===M%65536),a.wasmMemory=new WebAssembly.Memory({initial:M/65536,maximum:M/65536}),buffer=a.wasmMemory.buffer):buffer=new ArrayBuffer(M),assert(buffer.byteLength===M),a.buffer=buffer);ja();B[0]=1668509029;ia[1]=25459;\r\nif(115!==A[2]||99!==A[3])throw\"Runtime error: expected the system to be little-endian!\";function N(b){for(;0<b.length;){var c=b.shift();if(\"function\"==typeof c)c();else{var e=c.l;\"number\"===typeof e?void 0===c.b?a.dynCall_v(e):a.dynCall_vi(e,c.b):e(void 0===c.b?null:c.b)}}}var na=[],oa=[],qa=[],ra=[],O=!1;function sa(){var b=a.preRun.shift();na.unshift(b)}assert(Math.imul&&Math.fround&&Math.clz32&&Math.trunc,\"this is a legacy browser, build with LEGACY_VM_SUPPORT\");var P=0,Q=null,S=null,T={};\r\nfunction ta(){P++;a.monitorRunDependencies&&a.monitorRunDependencies(P);assert(!T[\"wasm-instantiate\"]);T[\"wasm-instantiate\"]=1;null===Q&&\"undefined\"!==typeof setInterval&&(Q=setInterval(function(){if(z)clearInterval(Q),Q=null;else{var b=!1,c;for(c in T)b||(b=!0,v(\"still waiting on run dependencies:\")),v(\"dependency: \"+c);b&&v(\"(end of list)\")}},1E4))}a.preloadedImages={};a.preloadedAudios={};\r\nfunction ua(){x(\"Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1\")}var FS={};a.FS_createDataFile=function(){ua()};a.FS_createPreloadedFile=function(){ua()};\r\nfunction U(b){return String.prototype.startsWith?b.startsWith(\"data:application/octet-stream;base64,\"):0===b.indexOf(\"data:application/octet-stream;base64,\")}\r\n(function(){function b(){try{if(a.wasmBinary)return new Uint8Array(a.wasmBinary);if(a.readBinary)return a.readBinary(m);throw\"on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)\";}catch(R){x(R)}}function c(){return a.wasmBinary||!k&&!l||\"function\"!==typeof fetch?new Promise(function(c){c(b())}):fetch(m,{credentials:\"same-origin\"}).then(function(b){if(!b.ok)throw\"failed to load wasm binary file at '\"+m+\r\n\"'\";return b.arrayBuffer()}).catch(function(){return b()})}function e(b){function pa(b){r=b.exports;if(r.memory){b=r.memory;var c=a.buffer;b.byteLength<c.byteLength&&v(\"the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here\");c=new Int8Array(c);(new Int8Array(b)).set(c);a.buffer=buffer=b;ja()}a.asm=r;a.usingWasm=!0;P--;a.monitorRunDependencies&&a.monitorRunDependencies(P);assert(T[\"wasm-instantiate\"]);delete T[\"wasm-instantiate\"];0==P&&(null!==Q&&\r\n(clearInterval(Q),Q=null),S&&(b=S,S=null,b()))}function f(b){assert(a===e,\"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\");e=null;pa(b.instance)}function R(b){c().then(function(b){return WebAssembly.instantiate(b,n)}).then(b).catch(function(b){v(\"failed to asynchronously prepare wasm: \"+b);x(b)})}if(\"object\"!==typeof WebAssembly)return x(\"No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.\"),v(\"no native wasm support detected\"),\r\n!1;if(!(a.wasmMemory instanceof WebAssembly.Memory))return v(\"no native wasm Memory in use\"),!1;b.memory=a.wasmMemory;n.global={NaN:NaN,Infinity:Infinity};n[\"global.Math\"]=Math;n.env=b;ta();if(a.instantiateWasm)try{return a.instantiateWasm(n,pa)}catch(ya){return v(\"Module.instantiateWasm callback failed with error: \"+ya),!1}var e=a;a.wasmBinary||\"function\"!==typeof WebAssembly.instantiateStreaming||U(m)||\"function\"!==typeof fetch?R(f):WebAssembly.instantiateStreaming(fetch(m,{credentials:\"same-origin\"}),\r\nn).then(f).catch(function(b){v(\"wasm streaming compile failed: \"+b);v(\"falling back to ArrayBuffer instantiation\");R(f)});return{}}var g=\"wasm_interface.wast\",m=\"wasm_interface.wasm\",t=\"wasm_interface.temp.asm.js\";\"function\"===typeof a.locateFile&&(U(g)||(g=a.locateFile(g)),U(m)||(m=a.locateFile(m)),U(t)||(t=a.locateFile(t)));var n={global:null,env:null,asm2wasm:da,parent:a},r=null;a.asmPreload=a.asm;var D=a.reallocBuffer;a.reallocBuffer=function(b){if(\"asmjs\"===Aa)var c=D(b);else a:{var f=a.usingWasm?\r\n65536:16777216;0<b%f&&(b+=f-b%f);f=a.buffer.byteLength;if(a.usingWasm)try{c=-1!==a.wasmMemory.grow((b-f)/65536)?a.buffer=a.wasmMemory.buffer:null;break a}catch(za){console.error(\"Module.reallocBuffer: Attempted to grow from \"+f+\" bytes to \"+b+\" bytes, but got error: \"+za);c=null;break a}c=void 0}return c};var Aa=\"\";a.asm=function(b,c){if(!c.table){b=a.wasmTableSize;void 0===b&&(b=1024);var f=a.wasmMaxTableSize;c.table=\"object\"===typeof WebAssembly&&\"function\"===typeof WebAssembly.Table?void 0!==f?\r\nnew WebAssembly.Table({initial:b,maximum:f,element:\"anyfunc\"}):new WebAssembly.Table({initial:b,element:\"anyfunc\"}):Array(b);a.wasmTable=c.table}c.memoryBase||(c.memoryBase=a.STATIC_BASE);c.tableBase||(c.tableBase=0);c=e(c);assert(c,\"no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods\");return c}})();E=1024;F=E+3152;oa.push();a.STATIC_BASE=E;a.STATIC_BUMP=3152;var va=F;F+=16;\r\nassert(0==va%8);function V(){return!!V.a}var W=0;function X(){W+=4;return B[W-4>>2]}var wa={};\r\nfunction Y(b,c){W=c;try{var e=X(),g=X(),m=X();b=0;Y.a||(Y.a=[null,[],[]],Y.h=function(b,c){var e=Y.a[b];assert(e);if(0===c||10===c){b=1===b?w:v;a:{for(var g=c=0;e[g];)++g;if(16<g-c&&e.subarray&&ea)c=ea.decode(e.subarray(c,g));else for(g=\"\";;){var f=e[c++];if(!f){c=g;break a}if(f&128){var m=e[c++]&63;if(192==(f&224))g+=String.fromCharCode((f&31)<<6|m);else{var n=e[c++]&63;if(224==(f&240))f=(f&15)<<12|m<<6|n;else{var r=e[c++]&63;if(240==(f&248))f=(f&7)<<18|m<<12|n<<6|r;else{var t=e[c++]&63;if(248==\r\n(f&252))f=(f&3)<<24|m<<18|n<<12|r<<6|t;else{var D=e[c++]&63;f=(f&1)<<30|m<<24|n<<18|r<<12|t<<6|D}}}65536>f?g+=String.fromCharCode(f):(f-=65536,g+=String.fromCharCode(55296|f>>10,56320|f&1023))}}else g+=String.fromCharCode(f)}}b(c);e.length=0}else e.push(c)});for(c=0;c<m;c++){for(var t=B[g+8*c>>2],n=B[g+(8*c+4)>>2],r=0;r<n;r++)Y.h(e,A[t+r]);b+=n}return b}catch(D){return x(D),-D.c}}assert(!G);var xa=F;F=F+4+15&-16;assert(F<M,\"not enough memory for static allocation - increase TOTAL_MEMORY\");K=xa;\r\nH=ka=ca(F);I=H+ma;J=ca(I);B[K>>2]=J;G=!0;assert(J<M,\"TOTAL_MEMORY not big enough for stack\");a.wasmTableSize=41;a.wasmMaxTableSize=41;a.f={};\r\na.g={enlargeMemory:function(){la()},getTotalMemory:function(){return M},abortOnCannotGrowMemory:la,abortStackOverflow:function(b){x(\"Stack overflow! Attempted to allocate \"+b+\" bytes on the stack, but stack has only \"+(I-ba()+b)+\" bytes available!\")},nullFunc_ii:function(b){v(\"Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");v(\"Build with ASSERTIONS=2 for more info.\");\r\nx(b)},nullFunc_iiii:function(b){v(\"Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");v(\"Build with ASSERTIONS=2 for more info.\");x(b)},nullFunc_v:function(b){v(\"Invalid function pointer called with signature 'v'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\r\nv(\"Build with ASSERTIONS=2 for more info.\");x(b)},nullFunc_vi:function(b){v(\"Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");v(\"Build with ASSERTIONS=2 for more info.\");x(b)},nullFunc_viiii:function(b){v(\"Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\r\nv(\"Build with ASSERTIONS=2 for more info.\");x(b)},nullFunc_viiiii:function(b){v(\"Invalid function pointer called with signature 'viiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");v(\"Build with ASSERTIONS=2 for more info.\");x(b)},nullFunc_viiiiii:function(b){v(\"Invalid function pointer called with signature 'viiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\r\nv(\"Build with ASSERTIONS=2 for more info.\");x(b)},___cxa_allocate_exception:function(b){return Ba(b)},___cxa_throw:function(b){\"uncaught_exception\"in V?V.a++:V.a=1;throw b+\" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.\";},___lock:function(){},___setErrNo:function(b){a.___errno_location?B[a.___errno_location()>>2]=b:v(\"failed to set errno from JS\");return b},___syscall140:function(b,c){W=c;\r\ntry{var e=wa.i();X();var g=X(),m=X(),t=X();FS.m(e,g,t);B[m>>2]=e.position;e.j&&0===g&&0===t&&(e.j=null);return 0}catch(n){return x(n),-n.c}},___syscall146:Y,___syscall54:function(b,c){W=c;return 0},___syscall6:function(b,c){W=c;try{var e=wa.i();FS.close(e);return 0}catch(g){return x(g),-g.c}},___unlock:function(){},_abort:function(){a.abort()},_emscripten_memcpy_big:function(b,c,e){A.set(A.subarray(c,c+e),b);return b},DYNAMICTOP_PTR:K,STACKTOP:ka,STACK_MAX:I};var Z=a.asm(a.f,a.g,buffer),Ca=Z.___errno_location;\r\nZ.___errno_location=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return Ca.apply(null,arguments)};var Da=Z._fflush;Z._fflush=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return Da.apply(null,arguments)};\r\nvar Ea=Z._free;Z._free=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return Ea.apply(null,arguments)};var Fa=Z._get_pitch_mpm_c;\r\nZ._get_pitch_mpm_c=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return Fa.apply(null,arguments)};var Ga=Z._malloc;Z._malloc=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return Ga.apply(null,arguments)};\r\nvar Ha=Z._sbrk;Z._sbrk=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return Ha.apply(null,arguments)};var Ia=Z.establishStackSpace;\r\nZ.establishStackSpace=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return Ia.apply(null,arguments)};var Ja=Z.getTempRet0;\r\nZ.getTempRet0=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return Ja.apply(null,arguments)};var Ka=Z.setTempRet0;Z.setTempRet0=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return Ka.apply(null,arguments)};\r\nvar La=Z.setThrew;Z.setThrew=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return La.apply(null,arguments)};var Ma=Z.stackAlloc;\r\nZ.stackAlloc=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return Ma.apply(null,arguments)};var Na=Z.stackRestore;Z.stackRestore=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return Na.apply(null,arguments)};\r\nvar Oa=Z.stackSave;Z.stackSave=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return Oa.apply(null,arguments)};a.asm=Z;\r\na.___errno_location=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm.___errno_location.apply(null,arguments)};\r\na._fflush=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm._fflush.apply(null,arguments)};a._free=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm._free.apply(null,arguments)};\r\na._get_pitch_mpm_c=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm._get_pitch_mpm_c.apply(null,arguments)};\r\nvar Ba=a._malloc=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm._malloc.apply(null,arguments)};a._sbrk=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm._sbrk.apply(null,arguments)};\r\na.establishStackSpace=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm.establishStackSpace.apply(null,arguments)};\r\na.getTempRet0=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm.getTempRet0.apply(null,arguments)};\r\na.setTempRet0=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm.setTempRet0.apply(null,arguments)};\r\na.setThrew=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm.setThrew.apply(null,arguments)};a.stackAlloc=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm.stackAlloc.apply(null,arguments)};\r\na.stackRestore=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm.stackRestore.apply(null,arguments)};\r\nvar ba=a.stackSave=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm.stackSave.apply(null,arguments)};\r\na.dynCall_v=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm.dynCall_v.apply(null,arguments)};\r\na.dynCall_vi=function(){assert(O,\"you need to wait for the runtime to be ready (e.g. wait for main() to be called)\");assert(!0,\"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)\");return a.asm.dynCall_vi.apply(null,arguments)};a.asm=Z;a.intArrayFromString||(a.intArrayFromString=function(){x(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.intArrayToString||(a.intArrayToString=function(){x(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.ccall||(a.ccall=function(){x(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.cwrap||(a.cwrap=function(){x(\"'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.setValue||(a.setValue=function(){x(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.getValue||(a.getValue=function(){x(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.allocate||(a.allocate=function(){x(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.getMemory||(a.getMemory=function(){x(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\")});a.Pointer_stringify||(a.Pointer_stringify=function(){x(\"'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.AsciiToString||(a.AsciiToString=function(){x(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.stringToAscii||(a.stringToAscii=function(){x(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.UTF8ArrayToString||(a.UTF8ArrayToString=function(){x(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.UTF8ToString||(a.UTF8ToString=function(){x(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.stringToUTF8Array||(a.stringToUTF8Array=function(){x(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.stringToUTF8||(a.stringToUTF8=function(){x(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.lengthBytesUTF8||(a.lengthBytesUTF8=function(){x(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.UTF16ToString||(a.UTF16ToString=function(){x(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.stringToUTF16||(a.stringToUTF16=function(){x(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.lengthBytesUTF16||(a.lengthBytesUTF16=function(){x(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.UTF32ToString||(a.UTF32ToString=function(){x(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.stringToUTF32||(a.stringToUTF32=function(){x(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.lengthBytesUTF32||(a.lengthBytesUTF32=function(){x(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.allocateUTF8||(a.allocateUTF8=function(){x(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.stackTrace||(a.stackTrace=function(){x(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.addOnPreRun||(a.addOnPreRun=function(){x(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.addOnInit||(a.addOnInit=function(){x(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.addOnPreMain||(a.addOnPreMain=function(){x(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.addOnExit||(a.addOnExit=function(){x(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.addOnPostRun||(a.addOnPostRun=function(){x(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.writeStringToMemory||(a.writeStringToMemory=function(){x(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.writeArrayToMemory||(a.writeArrayToMemory=function(){x(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.writeAsciiToMemory||(a.writeAsciiToMemory=function(){x(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.addRunDependency||(a.addRunDependency=function(){x(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\")});a.removeRunDependency||(a.removeRunDependency=function(){x(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\")});\r\na.FS||(a.FS=function(){x(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.FS_createFolder||(a.FS_createFolder=function(){x(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\")});a.FS_createPath||(a.FS_createPath=function(){x(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\")});\r\na.FS_createDataFile||(a.FS_createDataFile=function(){x(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\")});a.FS_createPreloadedFile||(a.FS_createPreloadedFile=function(){x(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\")});\r\na.FS_createLazyFile||(a.FS_createLazyFile=function(){x(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\")});a.FS_createLink||(a.FS_createLink=function(){x(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\")});\r\na.FS_createDevice||(a.FS_createDevice=function(){x(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\")});a.FS_unlink||(a.FS_unlink=function(){x(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\")});a.GL||(a.GL=function(){x(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.staticAlloc||(a.staticAlloc=function(){x(\"'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.dynamicAlloc||(a.dynamicAlloc=function(){x(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.warnOnce||(a.warnOnce=function(){x(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.loadDynamicLibrary||(a.loadDynamicLibrary=function(){x(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.loadWebAssemblyModule||(a.loadWebAssemblyModule=function(){x(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.getLEB||(a.getLEB=function(){x(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.getFunctionTables||(a.getFunctionTables=function(){x(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.alignFunctionTables||(a.alignFunctionTables=function(){x(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.registerFunctions||(a.registerFunctions=function(){x(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.addFunction||(a.addFunction=function(){x(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.removeFunction||(a.removeFunction=function(){x(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.getFuncWrapper||(a.getFuncWrapper=function(){x(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.prettyPrint||(a.prettyPrint=function(){x(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.makeBigInt||(a.makeBigInt=function(){x(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.dynCall||(a.dynCall=function(){x(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.getCompilerSetting||(a.getCompilerSetting=function(){x(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.stackSave||(a.stackSave=function(){x(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.stackRestore||(a.stackRestore=function(){x(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.stackAlloc||(a.stackAlloc=function(){x(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.establishStackSpace||(a.establishStackSpace=function(){x(\"'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});\r\na.print||(a.print=function(){x(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.printErr||(a.printErr=function(){x(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")});a.ALLOC_NORMAL||Object.defineProperty(a,\"ALLOC_NORMAL\",{get:function(){x(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")}});a.ALLOC_STACK||Object.defineProperty(a,\"ALLOC_STACK\",{get:function(){x(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")}});\r\na.ALLOC_STATIC||Object.defineProperty(a,\"ALLOC_STATIC\",{get:function(){x(\"'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")}});a.ALLOC_DYNAMIC||Object.defineProperty(a,\"ALLOC_DYNAMIC\",{get:function(){x(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")}});a.ALLOC_NONE||Object.defineProperty(a,\"ALLOC_NONE\",{get:function(){x(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\")}});\r\na.then=function(b){if(a.calledRun)b(a);else{var c=a.onRuntimeInitialized;a.onRuntimeInitialized=function(){c&&c();b(a)}}return a};S=function Pa(){a.calledRun||Qa();a.calledRun||(S=Pa)};\r\nfunction Qa(){function b(){if(!a.calledRun&&(a.calledRun=!0,!z)){L();O||(O=!0,N(oa));L();N(qa);if(a.onRuntimeInitialized)a.onRuntimeInitialized();assert(!a._main,'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');L();if(a.postRun)for(\"function\"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var b=a.postRun.shift();ra.unshift(b)}N(ra)}}if(!(0<P)){assert(0==(I&3));C[(I>>2)-1]=34821223;C[(I>>2)-2]=2310721022;if(a.preRun)for(\"function\"==\r\ntypeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)sa();N(na);0<P||a.calledRun||(a.setStatus?(a.setStatus(\"Running...\"),setTimeout(function(){setTimeout(function(){a.setStatus(\"\")},1);b()},1)):b(),L())}}a.run=Qa;var Ra=[];function x(b){if(a.onAbort)a.onAbort(b);void 0!==b?(w(b),v(b),b=JSON.stringify(b)):b=\"\";z=!0;var c=\"abort(\"+b+\") at \"+ha()+\"\";Ra&&Ra.forEach(function(e){c=e(c,b)});throw c;}a.abort=x;if(a.preInit)for(\"function\"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();\r\na.noExitRuntime=!0;Qa();\r\n\r\n\r\n  return Module;\r\n};\r\nif (true)\r\n    module.exports = Module;\r\n  else {}\r\n  \n\n//# sourceURL=webpack:///./releases/wasm_interface.js?");

/***/ }),

/***/ "./releases/wasm_interface.wasm":
/*!**************************************!*\
  !*** ./releases/wasm_interface.wasm ***!
  \**************************************/
/*! exports provided: ___errno_location, _fflush, _free, _get_pitch_mpm_c, _malloc, _sbrk, dynCall_v, dynCall_vi, establishStackSpace, getTempRet0, setTempRet0, setThrew, stackAlloc, stackRestore, stackSave */
/***/ (function(module, exports, __webpack_require__) {

eval("\"use strict\";\n// Instantiate WebAssembly module\nvar wasmExports = __webpack_require__.w[module.i];\n__webpack_require__.r(exports);\n// export exports from WebAssembly module\nfor(var name in wasmExports) if(name != \"__webpack_init__\") exports[name] = wasmExports[name];\n// exec imports from WebAssembly module (for esm order)\n\n\n// exec wasm module\nwasmExports[\"__webpack_init__\"]()\n\n//# sourceURL=webpack:///./releases/wasm_interface.wasm?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ })

/******/ });